<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Distance Tracker</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: white;
            color: black;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 400px;
            margin: 0 auto;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 30px;
            text-align: center;
        }

        .distance-display {
            font-size: 48px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
        }

        .scale-container {
            margin-bottom: 30px;
        }

        .scale-bar {
            width: 100%;
            height: 30px;
            border: 2px solid black;
            position: relative;
            background: white;
        }

        .scale-fill {
            height: 100%;
            background: black;
            width: 0%;
            transition: width 0.3s ease;
        }

        .scale-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 14px;
        }

        .scale-ticks {
            display: flex;
            justify-content: space-between;
            padding: 0 0;
            position: relative;
            height: 10px;
        }

        .tick {
            width: 2px;
            height: 10px;
            background: black;
        }

        button {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            background: white;
            color: black;
            border: 2px solid black;
            cursor: pointer;
            margin-bottom: 10px;
        }

        button:active {
            background: black;
            color: white;
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .status {
            text-align: center;
            margin-bottom: 20px;
            font-size: 14px;
            min-height: 20px;
        }

        .revealed-text {
            margin-top: 30px;
            padding: 20px;
            border: 2px solid black;
            line-height: 1.6;
            min-height: 150px;
        }

        .revealed-text .word {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .error {
            color: red;
            text-align: center;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Distance Tracker</h1>

        <div class="status" id="status">Press Start to begin tracking</div>
        <div class="error" id="error"></div>

        <div class="distance-display">
            <span id="distance">0</span>m
        </div>

        <div class="scale-container">
            <div class="scale-bar">
                <div class="scale-fill" id="scaleFill"></div>
            </div>
            <div class="scale-ticks">
                <div class="tick"></div>
                <div class="tick"></div>
                <div class="tick"></div>
                <div class="tick"></div>
                <div class="tick"></div>
            </div>
            <div class="scale-labels">
                <span>0m</span>
                <span>25m</span>
                <span>50m</span>
                <span>75m</span>
                <span>100m</span>
            </div>
        </div>

        <button id="startBtn">Start</button>
        <button id="resetBtn" style="display: none;">Reset</button>

        <div class="revealed-text" id="revealedText"></div>
    </div>

    <script>
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const distanceEl = document.getElementById('distance');
        const scaleFill = document.getElementById('scaleFill');
        const statusEl = document.getElementById('status');
        const errorEl = document.getElementById('error');
        const revealedText = document.getElementById('revealedText');

        let startPosition = null;
        let watchId = null;

        // Text loaded from source.html
        let sourceHTML = '';
        let wordSpans = [];

        // Configuration
        const APPEAR_START = 40;    // Words start appearing at 40m
        const APPEAR_END = 100;     // All words visible at 100m
        const DISAPPEAR_END = 80;   // All words gone by 80m when returning
        const MIN_OPACITY = 0.1;    // Starting opacity at 40m
        const MAX_OPACITY = 1.0;    // Full opacity at 100m

        // Track which word indices are currently visible
        let visibleIndices = new Set();
        let previousDistance = 0;

        // Load HTML from source.html
        async function loadSourceText() {
            try {
                const response = await fetch('source.html');
                if (!response.ok) {
                    throw new Error('Failed to load source.html');
                }
                sourceHTML = await response.text();
                initializeWords();
            } catch (error) {
                errorEl.textContent = 'Error loading text: ' + error.message;
            }
        }

        // Walk through all text nodes and wrap each word in a span
        function wrapWordsInTextNode(textNode, spans) {
            const text = textNode.textContent;
            const words = text.split(/(\s+)/); // Split but keep whitespace
            const fragment = document.createDocumentFragment();

            words.forEach(part => {
                if (part.match(/^\s+$/)) {
                    // Whitespace - add as text node
                    fragment.appendChild(document.createTextNode(part));
                } else if (part.length > 0) {
                    // Word - wrap in span
                    const span = document.createElement('span');
                    span.className = 'word';
                    span.textContent = part;
                    fragment.appendChild(span);
                    spans.push(span);
                }
            });

            textNode.parentNode.replaceChild(fragment, textNode);
        }

        // Recursively process all text nodes in an element
        function processTextNodes(element, spans) {
            // Get all child nodes as array (since we'll be modifying the DOM)
            const childNodes = Array.from(element.childNodes);

            childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) {
                    if (node.textContent.trim().length > 0) {
                        wrapWordsInTextNode(node, spans);
                    }
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    processTextNodes(node, spans);
                }
            });
        }

        // Initialize word spans from HTML content
        function initializeWords() {
            revealedText.innerHTML = sourceHTML;
            wordSpans = [];
            visibleIndices = new Set();
            previousDistance = 0;
            processTextNodes(revealedText, wordSpans);
        }

        // Randomly select n items from an array
        function randomSelect(array, n) {
            const shuffled = [...array].sort(() => Math.random() - 0.5);
            return shuffled.slice(0, n);
        }

        // Calculate opacity based on distance (10% at 40m, 100% at 100m)
        function calculateOpacity(distance) {
            if (distance <= APPEAR_START) return MIN_OPACITY;
            if (distance >= APPEAR_END) return MAX_OPACITY;
            const progress = (distance - APPEAR_START) / (APPEAR_END - APPEAR_START);
            return MIN_OPACITY + progress * (MAX_OPACITY - MIN_OPACITY);
        }

        // Update opacity for all visible words
        function updateVisibleOpacity(opacity) {
            visibleIndices.forEach(index => {
                wordSpans[index].style.opacity = opacity;
            });
        }

        // Update visible words based on distance
        function updateWords(distance) {
            const isMovingAway = distance >= previousDistance;
            previousDistance = distance;

            // Calculate target word count based on direction
            let targetWordCount = 0;

            if (isMovingAway) {
                // Moving away: use 40-100m range for appearing
                if (distance >= APPEAR_START) {
                    const percentage = Math.min((distance - APPEAR_START) / (APPEAR_END - APPEAR_START), 1);
                    targetWordCount = Math.floor(percentage * wordSpans.length);
                }
            } else {
                // Moving back: use 80-100m range for disappearing (faster)
                if (distance >= DISAPPEAR_END) {
                    const percentage = Math.min((distance - DISAPPEAR_END) / (APPEAR_END - DISAPPEAR_END), 1);
                    targetWordCount = Math.floor(percentage * wordSpans.length);
                }
                // Below 80m = 0 words
            }

            const currentWordCount = visibleIndices.size;

            if (targetWordCount > currentWordCount) {
                // Need to show more words - pick randomly from hidden ones
                const hiddenIndices = [];
                for (let i = 0; i < wordSpans.length; i++) {
                    if (!visibleIndices.has(i)) {
                        hiddenIndices.push(i);
                    }
                }
                const toReveal = randomSelect(hiddenIndices, targetWordCount - currentWordCount);
                const opacity = calculateOpacity(distance);
                toReveal.forEach(index => {
                    visibleIndices.add(index);
                    wordSpans[index].style.opacity = opacity;
                });
            } else if (targetWordCount < currentWordCount) {
                // Need to hide some words - pick randomly from visible ones
                const visibleArray = Array.from(visibleIndices);
                const toHide = randomSelect(visibleArray, currentWordCount - targetWordCount);
                toHide.forEach(index => {
                    visibleIndices.delete(index);
                    wordSpans[index].style.opacity = 0;
                });
            }

            // Update opacity of remaining visible words based on current distance
            if (visibleIndices.size > 0) {
                updateVisibleOpacity(calculateOpacity(distance));
            }
        }

        // Load source text on page load
        loadSourceText();

        // Calculate distance between two coordinates using Haversine formula
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function toRad(deg) {
            return deg * (Math.PI / 180);
        }

        function updateDisplay(distance) {
            // Cap display at 100m
            const displayDistance = Math.min(Math.round(distance), 100);
            const percentage = Math.min((distance / 100) * 100, 100);

            distanceEl.textContent = displayDistance;
            scaleFill.style.width = percentage + '%';

            // Update words based on distance
            updateWords(distance);

            // Update status when reaching 100m
            if (distance >= 100) {
                statusEl.textContent = 'You reached 100m! Full text revealed.';
            } else if (startPosition) {
                statusEl.textContent = 'Tracking... Walk away from your start point';
            }
        }

        function handlePosition(position) {
            const { latitude, longitude } = position.coords;

            if (!startPosition) {
                startPosition = { latitude, longitude };
                statusEl.textContent = 'Tracking... Walk away from your start point';
                return;
            }

            const distance = calculateDistance(
                startPosition.latitude,
                startPosition.longitude,
                latitude,
                longitude
            );

            updateDisplay(distance);
        }

        function handleError(error) {
            let message = '';
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    message = 'Location permission denied. Please enable location access.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    message = 'Location unavailable. Please try again.';
                    break;
                case error.TIMEOUT:
                    message = 'Location request timed out. Please try again.';
                    break;
                default:
                    message = 'An error occurred getting your location.';
            }
            errorEl.textContent = message;
            stopTracking();
        }

        function startTracking() {
            if (!navigator.geolocation) {
                errorEl.textContent = 'Geolocation is not supported by your browser.';
                return;
            }

            errorEl.textContent = '';
            statusEl.textContent = 'Getting your location...';
            startBtn.disabled = true;

            const options = {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            };

            watchId = navigator.geolocation.watchPosition(
                handlePosition,
                handleError,
                options
            );

            startBtn.style.display = 'none';
            resetBtn.style.display = 'block';
        }

        function stopTracking() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
        }

        function reset() {
            stopTracking();
            startPosition = null;
            distanceEl.textContent = '0';
            scaleFill.style.width = '0%';
            initializeWords(); // Reset all words to hidden
            statusEl.textContent = 'Press Start to begin tracking';
            errorEl.textContent = '';
            startBtn.style.display = 'block';
            startBtn.disabled = false;
            resetBtn.style.display = 'none';
        }

        startBtn.addEventListener('click', startTracking);
        resetBtn.addEventListener('click', reset);
    </script>
</body>
</html>
